"use strict";(self.webpackChunkfundamentals=self.webpackChunkfundamentals||[]).push([[57],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>d});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),s=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},u=function(e){var t=s(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=s(a),h=i,d=m["".concat(l,".").concat(h)]||m[h]||c[h]||r;return a?n.createElement(d,p(p({ref:t},u),{},{components:a})):n.createElement(d,p({ref:t},u))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,p=new Array(r);p[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:i,p[1]=o;for(var s=2;s<r;s++)p[s]=a[s];return n.createElement.apply(null,p)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1847:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>p,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var n=a(7462),i=(a(7294),a(3905));const r={sidebar_position:4},p="Typescript in React",o={unversionedId:"4 React/4 Typescript in React",id:"4 React/4 Typescript in React",title:"Typescript in React",description:"https://youtu.be/TPACABQTHvM?si=Jq9kThcOggAwfwuT",source:"@site/docs/4 React/4 Typescript in React.md",sourceDirName:"4 React",slug:"/4 React/4 Typescript in React",permalink:"/fundamentals/4 React/4 Typescript in React",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"React Native",permalink:"/fundamentals/4 React/3 React Native"},next:{title:"FIGMA",permalink:"/fundamentals/category/figma"}},l={},s=[{value:"<strong>=&gt;</strong> Introduction",id:"-introduction",level:3},{value:"<strong>=&gt;</strong> JSX to TSX",id:"-jsx-to-tsx",level:3},{value:"<strong>=&gt;</strong> Typing variables",id:"-typing-variables",level:3},{value:"<strong>=&gt;</strong> Typing functions",id:"-typing-functions",level:3},{value:"<strong>=&gt;</strong> Typing React components",id:"-typing-react-components",level:3},{value:"<strong>=&gt;</strong> React.FC",id:"-reactfc",level:3},{value:"<strong>=&gt;</strong> Typing props",id:"-typing-props",level:3},{value:"<strong>=&gt;</strong> Extracting type",id:"-extracting-type",level:3},{value:"<strong>=&gt;</strong> Benefits of TypeScript",id:"-benefits-of-typescript",level:3},{value:"<strong>=&gt;</strong> Optional",id:"-optional",level:3},{value:"<strong>=&gt;</strong> Benefits of TypeScript (cont.)",id:"-benefits-of-typescript-cont",level:3},{value:"<strong>=&gt;</strong> Union type",id:"-union-type",level:3},{value:"<strong>=&gt;</strong> Typing arrays",id:"-typing-arrays",level:3},{value:"<strong>=&gt;</strong> Tuple Type",id:"-tuple-type",level:3},{value:"<strong>=&gt;</strong> React.CSSProperties",id:"-reactcssproperties",level:3},{value:"<strong>=&gt;</strong> Record type",id:"-record-type",level:3},{value:"<strong>=&gt;</strong> Typing functions",id:"-typing-functions-1",level:3},{value:"<strong>=&gt;</strong> Typing children (React.ReactNode)",id:"-typing-children-reactreactnode",level:3},{value:"<strong>=&gt;</strong> React.JSX.Element vs React.ReactNode",id:"-reactjsxelement-vs-reactreactnode",level:3},{value:"<strong>=&gt;</strong> Typing <code>useState</code> Setter Function",id:"-typing-usestate-setter-function",level:3},{value:"<strong>=&gt;</strong> Default Prop Values",id:"-default-prop-values",level:3},{value:"<strong>=&gt;</strong> Type Alias vs Interface",id:"-type-alias-vs-interface",level:3},{value:"<strong>=&gt;</strong> ComponentPropsWithoutRef",id:"-componentpropswithoutref",level:3},{value:"<strong>=&gt;</strong> Rest and Spread",id:"-rest-and-spread",level:3},{value:"<strong>=&gt;</strong> Intersection (&amp;)",id:"-intersection-",level:3},{value:"<strong>=&gt;</strong> Interface extends",id:"-interface-extends",level:3},{value:"<strong>=&gt;</strong> Typing event handler functions",id:"-typing-event-handler-functions",level:3},{value:"<strong>=&gt;</strong> Typing useState hook",id:"-typing-usestate-hook",level:3},{value:"<strong>=&gt;</strong> Typing useRef hook",id:"-typing-useref-hook",level:3},{value:"<strong>=&gt;</strong> Using <code>as const</code>",id:"-using-as-const",level:3},{value:"<strong>=&gt;</strong> Using the <code>Omit</code> Utility",id:"-using-the-omit-utility",level:3},{value:"<strong>=&gt;</strong> &#39;as&#39; Type Assertion",id:"-as-type-assertion",level:3},{value:"<strong>=&gt;</strong> Generics (EASY!)",id:"-generics-easy",level:3},{value:"<strong>=&gt;</strong> Generics in React",id:"-generics-in-react",level:3},{value:"<strong>=&gt;</strong> <code>index.d.ts</code> vs. <code>types.ts</code>",id:"-indexdts-vs-typests",level:3},{value:"<strong>=&gt;</strong> <code>import type</code>",id:"-import-type",level:3},{value:"<strong>=&gt;</strong> &#39;unknown&#39; type",id:"-unknown-type",level:3},{value:"<strong>=&gt;</strong> Zod",id:"-zod",level:3},{value:"<strong>=&gt;</strong> ts-reset Library",id:"-ts-reset-library",level:3},{value:"<strong>=&gt;</strong> Third-party types (&#39;@types&#39; / DefinitelyTyped)",id:"-third-party-types-types--definitelytyped",level:3},{value:"<strong>=&gt;</strong> tsconfig.json",id:"-tsconfigjson",level:3},{value:"<strong>=&gt;</strong> next-env.d.ts",id:"-next-envdts",level:3}],u={toc:s},m="wrapper";function c(e){let{components:t,...a}=e;return(0,i.kt)(m,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"typescript-in-react"},"Typescript in React"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://youtu.be/TPACABQTHvM?si=Jq9kThcOggAwfwuT"},"https://youtu.be/TPACABQTHvM?si=Jq9kThcOggAwfwuT")),(0,i.kt)("h3",{id:"-introduction"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Introduction"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you want to be a React developer these days, you also need to know TypeScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"TypeScript has become a de facto standard in React applications.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In this video, I'll show you all the TypeScript things that you need to know as a React developer."))),(0,i.kt)("h3",{id:"-jsx-to-tsx"},(0,i.kt)("strong",{parentName:"h3"},"=>")," JSX to TSX"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So right now, you can see I have a simple button component, and it's using the JSX extension.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if you're ready for this, let's convert this into TSX.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I'm going to say this button now needs to start using TypeScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You can see when I do that, it immediately changes this icon here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I'm going to press enter, and now we have enabled TypeScript in this file."))),(0,i.kt)("h3",{id:"-typing-variables"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing variables"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's start off with the most common things you want to do in TypeScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's say we have some kind of variable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I can just write a variable like I'm always doing in JavaScript, but now if you hover this variable, you can see that there is some type connected to this, and we have not specified this type ourselves.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We could do that.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We can say this ",(0,i.kt)("inlineCode",{parentName:"p"},"URL")," is going to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," (you use the colon and then the type).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We could also say ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", and then you're going to get red squiggly lines because now we're trying to assign a string to a variable that we just annotated as a number.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So it should be a string, but you don't have to do this because TypeScript is smart enough to infer from what you're assigning to that variable what the type is going to be.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It sees that you're trying to assign a string to this variable, so it will automatically infer this variable to be of type string, so we don't need to specify that.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now, what's the benefit of having that type? Well, now later if I try to assign some other value to it that's a different type, I'm going to get a warning, a red squiggly line from TypeScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I'm trying to assign a number now to a variable that's supposed to be of type string, so TypeScript is helping us out here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It's telling us this is probably not what you want to do."))),(0,i.kt)("h3",{id:"-typing-functions"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing functions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Besides variables, we also often want to type functions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's say we have some function here, ",(0,i.kt)("inlineCode",{parentName:"p"},"convertCurrency"),", and it will take two arguments, let's say an ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," and then also the ",(0,i.kt)("inlineCode",{parentName:"p"},"currency")," that we want to convert that amount into.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"And then here in the function body, we would have the actual implementation.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now, in the function body, typically we don't want to type anything, but we do want to type the function parameters.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you don't type them, actually we're going to get red squiggly lines here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We're going to get a warning from TypeScript because it can't infer anything here, and we haven't specified it ourselves.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So by default, it's going to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"any"),", which is not what we want.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"any")," means anything goes; we can do whatever we want with it.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It basically defeats the purpose of using TypeScript in the first place if you're using ",(0,i.kt)("inlineCode",{parentName:"p"},"any"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We do want to type this as specifically as we can, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"amount")," is going to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", let's say, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"currency")," can be a string (USD, EU for Euro).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So then I can call that function ",(0,i.kt)("inlineCode",{parentName:"p"},"convertCurrency")," with, for example, the number 100 and then a string.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If I now make a mistake here, if I now type in a string as the first argument, you can see TypeScript says, \"Hey, you're trying to pass a string here, but it's expecting a number type.\"")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So TypeScript is helping us out here; it prevents us from making this mistake.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Also, if I try to pass in another number here as the second argument, TypeScript is telling us, "Nope, that\'s not what you want to do; you want to pass a string here."')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"And then we can also specify the return type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This is usually not necessary, but sometimes you want to do that.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if you want to specify what this function should return, maybe it should return a string, let's say, then if you call that function, you're going to get back a string.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I get red squiggly lines now because I'm not returning anything here in the function body because it's just an example."))),(0,i.kt)("p",null,"Certainly, here is the provided text transcribed in Markdown format with h3 tags, and each sentence starting with a bullet point:"),(0,i.kt)("h3",{id:"-typing-react-components"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing React components"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So now let's talk about how you can use this in React.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In React, we have components, and these are actually just functions like we just saw except you write a name with a capital case, and in the world of React, we call these parameters props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So typically, you're going to get props here, and just like before, we want to type those parameters; we want to type the props, and we don't really want to type the return values.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So with React components, typically the only thing you want to type are the props."))),(0,i.kt)("h3",{id:"-reactfc"},(0,i.kt)("strong",{parentName:"h3"},"=>")," React.FC"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In the past, people often did the following to type components.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if you had some component function and then to type it, people would use ",(0,i.kt)("inlineCode",{parentName:"p"},": React.FC")," and then in here, you could specify the type of the component props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This looks a bit complicated, but this is how it was done mostly in the past.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You will still see this sometimes, but there are some issues with this ",(0,i.kt)("inlineCode",{parentName:"p"},"FC"),", and therefore it has gotten out of fashion.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"And it was also only possible to type this if you wrote your component function like this so as an arrow function.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You can still do that, of course, nothing wrong with it.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Personally, I prefer this traditional function syntax for a component."))),(0,i.kt)("h3",{id:"-typing-props"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing props"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's say that our function is going to receive some props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So I have added the button to our page here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I'm using the component, and now let's say I want to be able to pass, let's say, the background color.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I want to be able to set the background color when I use this component, right? Maybe I want to be able to set it to Red.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So I should be able to pass in this background color prop, but if I do that now, I get a warning from TypeScript because TypeScript is telling us you're not accepting any props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So now we need to actually accept the props, so we have ",(0,i.kt)("inlineCode",{parentName:"p"},"props"),", and that's just an object that holds all the props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if we want to get the background color from there, we can do ",(0,i.kt)("inlineCode",{parentName:"p"},"props.backgroundColor"),", and then we can use that background color here in the class, then to change the background color, let's say.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"But let's focus on TypeScript in this video, so now we have props, but we haven't typed this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So to type this, we can use a colon, and now it's not going to be ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"number")," because ",(0,i.kt)("inlineCode",{parentName:"p"},"props")," is an object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To type an object, we can just use curly braces, and then we can say in there there's going to be a property ",(0,i.kt)("inlineCode",{parentName:"p"},"backgroundColor"),", and that one is going to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if I do this, this is now properly typed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The props is an object, and in there, we just have ",(0,i.kt)("inlineCode",{parentName:"p"},"backgroundColor")," as a string.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If I now try to pass a number, let's say number 5, we get an issue from TypeScript, and TypeScript is helping us out.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You have to pass a string here now.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Typically, you don't write your React components like this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Typically, you destructure this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So here you can destructure it like this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead of doing ",(0,i.kt)("inlineCode",{parentName:"p"},"props.backgroundColor"),", you can just write ",(0,i.kt)("inlineCode",{parentName:"p"},"backgroundColor"),", and then just destructure it from ",(0,i.kt)("inlineCode",{parentName:"p"},"props")," like that or just immediately here in the parameter list, immediately destructure it here, and that's actually more common.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So instead of writing ",(0,i.kt)("inlineCode",{parentName:"p"},"props"),", you can actually already just immediately write that destructuring in the parameter list like this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So this is a more typical syntax that you're going to see in React components.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So the ",(0,i.kt)("inlineCode",{parentName:"p"},"props")," here, it's still an object, but we are immediately destructuring it here, and therefore we should still describe this as an object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now let's say we want to pass a font size as well.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So what we want to be able to do is say the font size should be some number.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's say maybe font size should be 30, and we get red squiggly lines because we are not accepting a prop called font size here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So here now we need to accept a prop called font size, and we are immediately going to destructure that here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"But we also need to specify this to TypeScript; we're going to tell TypeScript, \"Hey, we expect a font size, and that's going to be of type number.\"")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The benefit of this is now when I try to pass something like 40 pixels, let's say, which is a pretty common mistake that you could make here, TypeScript is going to tell us, \"Hey, don't do this; you should pass a number here.\" Right?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So you can already see TypeScript is helping us out here; it's preventing us from making mistakes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So we have the type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", type ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", and the third common primitive type is ",(0,i.kt)("inlineCode",{parentName:"p"},"Boolean"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So let's say we also have some ",(0,i.kt)("inlineCode",{parentName:"p"},"Boolean"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We want to be able to specify whether this button should be a pill shape or not.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So we could say ",(0,i.kt)("inlineCode",{parentName:"p"},"pillShape")," should be ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),"."))),(0,i.kt)("h3",{id:"-extracting-type"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Extracting type"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's say so now we need to accept a pill shape here so we'll say we're going to destructure that pill shape from the props and then we're going to specify it here for TypeScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We're going to say this is going to be a Boolean true or false.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now you can see the syntax here is quite ugly; it looks like we're sort of repeating ourselves.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So we have curly braces here with all these props, and then we sort of have the same here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It looks like the same thing, so it's bloating up our components here quite a bit, especially if you have many props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So instead of writing it in line like this, maybe we should extract this into a separate type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We're going to create a separate type, so in TypeScript, we have type ",(0,i.kt)("inlineCode",{parentName:"p"},"Ty"),", and we can call that let's say ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonProps"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I like to use the name of the component and then just add ",(0,i.kt)("inlineCode",{parentName:"p"},"Props"),", and we can say, well, this ",(0,i.kt)("inlineCode",{parentName:"p"},"props")," is going to be an object with all this stuff here, all these properties.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So we can just paste this here, and now we can use this name instead of writing it in line.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You can see now it's much cleaner, it works the exact same."))),(0,i.kt)("h3",{id:"-benefits-of-typescript"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Benefits of TypeScript"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So the benefits are TypeScript helps us prevent mistakes, but it goes beyond that.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's say we don't know the properties that we can pass here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I'm using the button, and I want to see the options essentially so I can press control space here, and TypeScript is telling us these are the properties that this button can accept.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We have background color of type string, we have font size of type number, and we have this pill shape of type Boolean, so I get this very handy intellisense as well."))),(0,i.kt)("h3",{id:"-optional"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Optional"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When I remove these now, by the way, we see red squiggly lines.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if we look at this, we can see there is some problem here, so we are not passing anything here, and that's a problem because the way that we've done it now is that we have made these mandatory.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if I add two of them back, we still get this red squiggly line because we are still missing one, which is pill shape.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We don't have pill shape here, but the way that we've done it now is that these are all mandatory, so if we miss one, we're going to get a warning.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I can make them optional by having this question mark here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So now if I go back, you can see the red squiggly line is gone because the pill shape now is optional."))),(0,i.kt)("h3",{id:"-benefits-of-typescript-cont"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Benefits of TypeScript (cont.)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Another benefit of TypeScript is that let's say I want to use some method here on the background color variable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This is a string, so if I do this ",(0,i.kt)("inlineCode",{parentName:"p"},"toUpperCase()"),", this works without a problem.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"But if I try to do the same thing with font size, which is of type number, I get a warning here because ",(0,i.kt)("inlineCode",{parentName:"p"},"toUpperCase()")," is a method that doesn't exist on type number.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"TypeScript helps us out with using these methods as well if we don't type this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if I just remove this ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," type, font size is going to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," by default, and sometimes you will also see people make that explicit, so they'll say this font size is going to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"any"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," means anything goes, so when I do this now, suddenly I don't get red squiggly line here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So now I could be passing a number here and trying to do ",(0,i.kt)("inlineCode",{parentName:"p"},".toUpperCase()"),", but this would cause an error.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It could cause our application to crash; it could cause a lot of bugs in our code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"And that's the problem with the ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," type; ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," means anything goes, you can do whatever you want, but then why are you using TypeScript in the first place? So we do want to type these things as specifically as we can.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So here when I type it as number again, you can see we get a warning.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So we can fix it, so let me remove that.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We are not typing the parameters of this component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Do we also need to type the return value of this component?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Type return value of component?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Component so it's returning this button here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This is something called a JSX element.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This button here, we don't have to type this ourselves.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So if I remove this and just hover button, you can see it's already inferred that we are returning this JSX element.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So TypeScript can infer a lot; you just have to follow the red squiggly lines."))),(0,i.kt)("h3",{id:"-union-type"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Union type"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's talk a little bit more about the other types that we have in TypeScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead of accepting any string for the background color, maybe we can be more specific than that.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Maybe we only want to allow the string red or the string blue or the string green.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So you use this pipe symbol, and this entire thing is called a union type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It's possible that we want to use that for other properties as well.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, we may also have a text color prop, and maybe that one needs to accept the same strings.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now we are duplicating ourselves, so what we can do is we can extract this out into its own type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So we can have another type here, and we can simply call that let's say colors, and that's going to be the union type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now, I named this colors in the plural, but typically it's actually better to leave this as the singular name, so the color is going to be either red, blue, or green, and then we can specify color here.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Right, so you can extract new types like that and just combine them like this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now, if I want to make a change here, maybe add another color or other colors, I only have to change it in one place now because I added text color here, and I didn't make it optional.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So now we're going to get red squiggly lines here because I'm not passing text color.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So let's say I make text color the string purple; now we get rid of the red squiggly lines."))),(0,i.kt)("h3",{id:"-typing-arrays"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing arrays"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Arrays, maybe we want to accept a padding prop, and with padding, you have multiple sides, right? So you have top, right, bottom, left, so maybe this can be some kind of array.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So what we can do is something like this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So it shouldn't be just a number; it should be an array of numbers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You can just tack on these square brackets, and that means it should be an array of this type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I can do the same thing here, and now it's going to be an array of Boolean.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"I can even do it with my own custom type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Right, now it's going to be an array of these colors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"And for padding now, I need to pass it in, so how does that look like? Well, for padding now, I need to pass an array here, so it's going to be square brackets, and it should all be numbers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Right, so if I try to do something like 5 pixels, 10 pixels, TypeScript is warning me, "Hey, this shouldn\'t be in this format; it should be a number." Type string is not assignable to type number.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So it should be 5, 10, 20, 50."))),(0,i.kt)("h3",{id:"-tuple-type"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Tuple Type"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The problem here is that I can add even more values without restricting the length.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, there is another type in TypeScript that addresses this issue, and it's called a Tuple.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead of writing the type inline like this, you should define it as an array.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So, if you specify the types as ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", like this, you create what's known as a Tuple.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A Tuple is essentially a more specific type of array in TypeScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It allows you to define the number of elements and their specific types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, in this case, we've defined a Tuple with four numbers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If I try to add more than four elements, TypeScript will issue a warning, prompting me to correct the issue.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So, to resolve this problem, I simply need to remove the excess values from the array.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Additionally, I should also update the parameter list to accept this Tuple as an argument."))),(0,i.kt)("h3",{id:"-reactcssproperties"},(0,i.kt)("strong",{parentName:"h3"},"=>")," React.CSSProperties"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In addition to the previous props, we can also add text color and padding. While I've been using Tailwind CSS, you can use plain styles as well. In React, we have the ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," attribute, where you can pass an object to define the styles for an element.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You can define this object with curly braces and set various properties like ",(0,i.kt)("inlineCode",{parentName:"p"},"background color"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"color"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"font size"),", and more.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you're using a code editor with features like code completion (e.g., Copilot), it can help you by suggesting available properties as you type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Rather than specifying each CSS property individually, you can streamline your code by using a single ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," object. This allows you to avoid having multiple style-related props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To accept this ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," object as a prop, you need to add it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"button")," component's props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When using JSX syntax, you can pass the object within curly braces as the value for the ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," prop.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," prop is an object that describes the CSS properties you want to apply to the component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"React also provides predefined types for handling CSS properties. You can leverage these types to ensure that your styles are correctly typed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For instance, instead of manually specifying your own style object, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"React.CSSProperties")," type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By doing so, you let React define the structure of the ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," object based on the CSS properties you want to use.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This approach ensures that you can pass any CSS property you want as part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It also helps catch errors, such as passing a number when a string is expected for a specific property.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To summarize, using the ",(0,i.kt)("inlineCode",{parentName:"p"},"style")," attribute in React allows you to efficiently manage styles by passing a single object containing the desired CSS properties. Leveraging predefined types like ",(0,i.kt)("inlineCode",{parentName:"p"},"React.CSSProperties")," ensures proper type checking and helps prevent common styling mistakes."))),(0,i.kt)("h3",{id:"-record-type"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Record type"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Style is an object used for defining CSS properties, but there are cases where you need to work with objects in a different way.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's consider a scenario where we want to create a prop for ",(0,i.kt)("inlineCode",{parentName:"p"},"border radius"),". Border radius defines rounded corners and can have values for top left, top right, bottom right, and bottom left corners.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To pass this information, we might want to use an object where each key represents a corner (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"top left"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"top right"),") and the values are numbers representing the radius for each corner.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The challenge is in typing this object correctly because the keys are strings, and the values are numbers.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you directly define the object, you'll encounter issues with TypeScript as it will not recognize the keys as string literals.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To solve this problem, you can use TypeScript's ",(0,i.kt)("inlineCode",{parentName:"p"},"Record")," type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Record")," type allows you to specify both the types for keys and values within an object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In this case, the keys should be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", and the values should be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By using ",(0,i.kt)("inlineCode",{parentName:"p"},"Record<string, number>"),", you are telling TypeScript that the object should have string keys and number values.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This ensures proper type checking and allows you to work with objects where keys and values have specific types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In summary, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Record")," type is useful when you need to define an object with specific key-value pairs, such as for managing CSS properties like ",(0,i.kt)("inlineCode",{parentName:"p"},"border radius"),". It helps TypeScript enforce the correct types for both keys and values in the object."))),(0,i.kt)("h3",{id:"-typing-functions-1"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing functions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In some cases, you may want to pass a function as a prop. For example, you might want to specify an action to be performed when a button is clicked.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To achieve this, you define a function elsewhere in your code (not inside the button component) and pass it as a prop to the button component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's assume you have an ",(0,i.kt)("inlineCode",{parentName:"p"},"onclick")," prop, which represents the function to be executed when the button is clicked.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You want to make sure that your button component accepts this ",(0,i.kt)("inlineCode",{parentName:"p"},"onclick")," prop correctly.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"First, you need to define the ",(0,i.kt)("inlineCode",{parentName:"p"},"onclick")," prop in your button component's prop types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This prop can be named something like ",(0,i.kt)("inlineCode",{parentName:"p"},"onClickHandler"),", and you should specify the expected type for it.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In TypeScript, you can type a function as a prop by using a specific syntax.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For a function that doesn't accept any parameters and doesn't return anything, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"() => void")," type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In this type definition, ",(0,i.kt)("inlineCode",{parentName:"p"},"()")," represents the absence of parameters, and ",(0,i.kt)("inlineCode",{parentName:"p"},"void")," signifies that the function doesn't return anything.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If your function accepts parameters, you specify the parameter types within the parentheses. For example, if your function accepts a string parameter named ",(0,i.kt)("inlineCode",{parentName:"p"},"test")," and returns a number, the type definition would be ",(0,i.kt)("inlineCode",{parentName:"p"},"(test: string) => number"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By defining the prop type in this way, you ensure that the function passed as a prop adheres to the expected parameter and return value types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This type safety helps prevent potential issues and errors when using the function within the button component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In summary, when passing functions as props, TypeScript allows you to specify the expected function type to ensure type safety and prevent potential issues related to function parameters and return values."))),(0,i.kt)("h3",{id:"-typing-children-reactreactnode"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing children (React.ReactNode)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Let\'s explore how to handle and type the "children" prop in a React component.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In your example, you have a custom button component that you want to use with different text content.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead of hardcoding the text within the component, you'd like to specify it when using the component, similar to how you pass props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In JSX, you can specify content between the opening and closing tags of a component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'However, to make this work properly and ensure type safety, you need to define and handle the "children" prop in your component.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'The "children" prop is a common pattern in React components, and it allows you to include dynamic content inside your custom components.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'When you use the "children" prop, you essentially pass content to your component as if it were another prop.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'In your custom button component, you should accept the "children" prop and make use of it.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'To properly type the "children" prop, you can use the ',(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode")," type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode")," is a TypeScript type that encompasses various types, including JSX elements, plain text, booleans, and more.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This type flexibility allows you to pass different types of content as children to your component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'In your component\'s prop types, you would specify the "children" prop like this: ',(0,i.kt)("inlineCode",{parentName:"p"},"children: React.ReactNode"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'By defining the "children" prop in this way, you indicate that it can accept any type of content.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This ensures that you can pass JSX elements, text, or other valid React content as children to your component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'When using the "children" prop within your component, you can simply render it where you want the content to appear.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This approach provides flexibility and allows you to use your custom component with various types of content.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In practice, you'll often use ",(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode"),' for the "children" prop to accommodate different content types and maintain type safety.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, if your component specifically expects only JSX elements as children and wants to restrict other types, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"React.JSX.Element")," type for stricter type checking.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The choice between ",(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"React.JSX.Element")," depends on your component's requirements and how flexible you want it to be when accepting content.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Regardless of the choice, properly handling the "children" prop is essential for creating versatile and reusable React components.'))),(0,i.kt)("h3",{id:"-reactjsxelement-vs-reactreactnode"},(0,i.kt)("strong",{parentName:"h3"},"=>")," React.JSX.Element vs React.ReactNode"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'When working with the "children" prop in React components, you have the option to use different types for type safety and specificity.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In your example, you're exploring the differences between ",(0,i.kt)("inlineCode",{parentName:"p"},"React.JSX.Element")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode"),' when handling the "children" prop.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"While this example may not have a practical use case, understanding these types can be helpful in more complex scenarios.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"React.JSX.Element")," is a type that specifically allows JSX elements to be passed as children.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you want to ensure that only JSX elements, like HTML tags or React components, can be used as children, you can use this type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For instance, if you have a component that expects specific child components, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"React.JSX.Element")," to restrict the input to those components only.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, this restrictiveness might not be suitable if you need more flexibility in your component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode"),", on the other hand, is a more general type that accepts various content types, including JSX elements, plain text, and booleans.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'It provides greater flexibility when handling the "children" prop because it allows a wider range of content to be used.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In some cases, you may want to allow different content types within your component, and that's where ",(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode")," becomes valuable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For instance, you might want to pass not only JSX elements but also text or other data as children to your component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Using ",(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode")," allows you to achieve this flexibility while maintaining type safety.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In practice, ",(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode"),' is often the preferred choice for handling the "children" prop because it accommodates various use cases.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It's a versatile type that aligns with React's design principles of composability and reusability.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When you use ",(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode"),", you can freely pass different content types as children, making your components more adaptable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, it's crucial to choose the appropriate type based on your component's specific requirements and the level of strictness you want to enforce.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Whether you opt for ",(0,i.kt)("inlineCode",{parentName:"p"},"React.JSX.Element")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"React.ReactNode"),", understanding the differences between these types allows you to make informed decisions when designing and typing your React components.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Ultimately, your choice should align with your component's intended behavior and how you intend to use it in your application."))),(0,i.kt)("h3",{id:"-typing-usestate-setter-function"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing ",(0,i.kt)("inlineCode",{parentName:"h3"},"useState")," Setter Function"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In some scenarios, you may need to manage state in a parent component while using child components.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's consider a situation where you have a count value in the parent component, and you want to update it when a button is clicked.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To achieve this, you'll typically pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function (the state updater) to the child component so it can modify the count.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When dealing with TypeScript, it's essential to correctly type the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function to ensure type safety.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"First, let's assume that you have some state variables, including ",(0,i.kt)("inlineCode",{parentName:"p"},"count"),", in your parent component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"These state variables are managed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"useState")," hook.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Since you mentioned Next.js, it's important to note that when using client-side hooks, you might need to convert your component to a client component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, the specifics of Next.js aren't the focus here; we're primarily concerned with typing the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now, the goal is to increment the count when a button is clicked, and for that, you need to pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function to the button component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This pattern of passing a setter function to a child component is quite common when managing state in React.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To achieve this, you need to accept the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function as a prop in your child component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"children"),' prop for the button\'s content, you can hardcode it as "Click me" for demonstration purposes.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The key part is defining the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function you receive in the child component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The type suggestion you received from Co-pilot is accurate and represents the appropriate type for the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, if you're not using Co-pilot, you can easily determine the type by hovering over the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function in your code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"TypeScript will provide you with the inferred type, which you can copy and use in your code.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In this case, the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount"),' is a "Setter function" that accepts only a ',(0,i.kt)("inlineCode",{parentName:"p"},"number")," as its argument.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It enforces that you can only update the count with numeric values, preventing potential type errors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"As a result, if you attempt to pass a string or any other data type instead of a number to ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount"),", TypeScript will issue a warning.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"With the correct type definition in place, you can safely use the ",(0,i.kt)("inlineCode",{parentName:"p"},"setCount")," function to update the count when the button is clicked.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By ensuring that your setter function is appropriately typed, you enhance the type safety of your React components, reducing the chances of runtime errors and improving code quality."))),(0,i.kt)("h3",{id:"-default-prop-values"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Default Prop Values"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When working with React components, you can define default values for props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"These default values are used when a prop is not explicitly provided, ensuring that your component can function properly even without all props being passed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's consider a scenario where you have a prop called ",(0,i.kt)("inlineCode",{parentName:"p"},"count"),", and you want to give it a default value of ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By specifying a default value in the component's prop declaration, you eliminate the need to provide a value for ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," every time you use the component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"With the default value set, TypeScript can automatically infer the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," to be a number.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This inference is based on the default value, and TypeScript recognizes that the default value is ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),", which is a numeric type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Therefore, you don't need to explicitly specify the type for ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," when you have default values.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Default prop values help streamline your code by reducing the need for repetitive type annotations, making your code cleaner and more maintainable."))),(0,i.kt)("h3",{id:"-type-alias-vs-interface"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Type Alias vs Interface"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In TypeScript, there are two primary ways to define the shape of an object: Type Alias and Interface.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So far, we've been using Type Aliases, which are introduced with the ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," keyword.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Type Aliases allow you to assign a name to a specific type, making it easier to reuse complex type definitions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, we can define a ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonProps")," type using Type Alias, where ",(0,i.kt)("inlineCode",{parentName:"p"},"text")," is a string and ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," is a number.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, TypeScript also offers the ",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," keyword for defining types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We can achieve the same result by using an interface called ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonProps"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"With interfaces, you don't use an equal sign to assign types, but rather describe the structure of an object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Some developers like to prefix their interfaces with "I" to indicate that it\'s an interface, and they may also prefix Type Aliases with "t" for clarity.')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Interfaces have some limitations. They can only describe objects, making it challenging to define other types like union types or literal types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For instance, if you want to define a type for a URL that is just a string, you can easily do it with a Type Alias, but not with an interface.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Interfaces are primarily focused on describing object shapes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"While you can use both Type Aliases and Interfaces, it's common in the TypeScript community to prefer Type Aliases because of their flexibility.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Type Aliases can handle a broader range of type definitions, making them more versatile for complex scenarios.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In this video, we'll primarily focus on Type Aliases, but we'll also explore how Interfaces work for those who prefer them."))),(0,i.kt)("h3",{id:"-componentpropswithoutref"},(0,i.kt)("strong",{parentName:"h3"},"=>")," ComponentPropsWithoutRef"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When creating a custom button component, we want to allow various attributes like ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"autofocus"),", and many others to be specified when using the component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For instance, we may want to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),' attribute to "submit" and ',(0,i.kt)("inlineCode",{parentName:"p"},"autofocus")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To accept these attributes as props, we need to define them individually in the component's prop type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, manually specifying each attribute can become cumbersome, especially when there are many attributes to consider.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To simplify this, we can utilize a helper type called ",(0,i.kt)("inlineCode",{parentName:"p"},"component props")," provided by React.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This type allows us to pass all the attributes of a native HTML element, such as a button, to our custom component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By using ",(0,i.kt)("inlineCode",{parentName:"p"},"component props"),", we can accept attributes like ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"autofocus")," without needing to define them one by one.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This approach is particularly useful when wrapping native elements like buttons or anchor tags in custom components.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When using ",(0,i.kt)("inlineCode",{parentName:"p"},"component props"),", we need to ensure it's within the React namespace, typically accessed as ",(0,i.kt)("inlineCode",{parentName:"p"},"react.component props"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This type simplifies the process of accepting attributes from the native HTML element.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, it's important to note that when dealing with refs, you may need to consider different variations of ",(0,i.kt)("inlineCode",{parentName:"p"},"component props"),", such as ",(0,i.kt)("inlineCode",{parentName:"p"},"component props with ref"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Depending on your use case, you can choose the appropriate ",(0,i.kt)("inlineCode",{parentName:"p"},"component props")," variant to suit your component's requirements."))),(0,i.kt)("h3",{id:"-rest-and-spread"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Rest and Spread"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In our button component, we have been destructuring the ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"autofocus")," attributes, but what if we have many other attributes to consider?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Manually specifying each attribute one by one would be impractical.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Fortunately, JavaScript provides the rest operator, which can be used to collect all remaining props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We can use the rest operator by adding ",(0,i.kt)("inlineCode",{parentName:"p"},"...rest")," (or any preferred name) in our function parameters.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This will gather all the additional attributes passed to our component into an array-like object named ",(0,i.kt)("inlineCode",{parentName:"p"},"rest"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"With the collected ",(0,i.kt)("inlineCode",{parentName:"p"},"rest")," object, we can easily spread its contents onto the native button element.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To do this, we use the spread operator, indicated by three dots (",(0,i.kt)("inlineCode",{parentName:"p"},"..."),").")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By spreading ",(0,i.kt)("inlineCode",{parentName:"p"},"rest"),", we can include all the other attributes like ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultValue"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName"),", or any other potential props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This approach allows us to efficiently manage and pass any number of attributes to our component without the need for manual specification."))),(0,i.kt)("h3",{id:"-intersection-"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Intersection (&)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We have now set up our button component to accept all the attributes of a native button element.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"But what if we want to accept additional props that aren't standard HTML attributes?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In TypeScript, we can achieve this by using the intersection operator (",(0,i.kt)("inlineCode",{parentName:"p"},"&"),").")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To do this, we first define the base type, which includes all the native attributes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Then, we use the ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," operator to intersect this base type with any additional props we want to include.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, let's say we want to introduce a ",(0,i.kt)("inlineCode",{parentName:"p"},"variant")," prop, which specifies if the button should be primary or secondary.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By using the intersection operator, we can accept both the standard button attributes and the ",(0,i.kt)("inlineCode",{parentName:"p"},"variant")," prop.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This allows us to have a flexible and extensible component that accommodates both standard and custom props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'In more complex scenarios, you can apply this concept to create a hierarchy of props, where a "super" component inherits the props of a "base" component and adds its own unique props using intersection.'))),(0,i.kt)("h3",{id:"-interface-extends"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Interface extends"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In TypeScript, you can extend the properties of one interface with another interface.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When using the ",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," keyword, you don't use the ",(0,i.kt)("inlineCode",{parentName:"p"},"=")," sign as you do with type aliases.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead, you use the ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," keyword to specify that one interface extends the properties of another.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, we can define an ",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," called ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonProps")," to represent the properties of a button component.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Then, we can create another ",(0,i.kt)("inlineCode",{parentName:"p"},"interface")," called ",(0,i.kt)("inlineCode",{parentName:"p"},"superButtonProps")," that extends ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonProps")," using the ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," keyword.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This way, ",(0,i.kt)("inlineCode",{parentName:"p"},"superButtonProps")," inherits all the properties of ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonProps"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This is similar to how you use the ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," operator with type aliases to intersect types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So, sometimes you use ",(0,i.kt)("inlineCode",{parentName:"p"},"extends")," with interfaces for extending properties and ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," with type aliases for intersecting types, depending on your specific needs."))),(0,i.kt)("h3",{id:"-typing-event-handler-functions"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing event handler functions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When working with event handlers in React, you often define functions that get triggered when an event occurs, such as an ",(0,i.kt)("inlineCode",{parentName:"p"},"onClick")," function for a button.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In TypeScript, you can type these event handlers to specify the expected event object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, if you have an ",(0,i.kt)("inlineCode",{parentName:"p"},"onClick")," event handler inline, TypeScript can automatically infer the type of the event object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, if you extract the function into a separate variable or function declaration, TypeScript loses context, and you need to manually type the event object parameter.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To do this, you can hover over the inline event handler to see the inferred type and then copy it to properly type your function.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For instance, if you have a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"handleClick"),", you can explicitly type the event parameter by using a colon followed by the event type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This way, your event handler functions are properly typed, whether they are used inline or extracted as separate functions.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This approach also applies to other event handlers like ",(0,i.kt)("inlineCode",{parentName:"p"},"onChange")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"onSubmit")," when dealing with form elements or other interactive components in React."))),(0,i.kt)("h3",{id:"-typing-usestate-hook"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing useState hook"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When using the ",(0,i.kt)("inlineCode",{parentName:"p"},"useState")," hook in TypeScript, you can often rely on TypeScript's type inference to determine the variable types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, if you declare a state variable like ",(0,i.kt)("inlineCode",{parentName:"p"},"count")," without specifying its type, TypeScript can infer that it's of type ",(0,i.kt)("inlineCode",{parentName:"p"},"number")," based on the initial value you provide.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Explicitly specifying the type with angled brackets (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"<string>"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"<number>"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"<boolean>"),") is not necessary in most cases because TypeScript can correctly infer it.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, when dealing with objects as initial values, it's crucial to define a custom type for the object to avoid type errors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For instance, if you initialize a ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," state with ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", TypeScript will infer its type as ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". To address this, create a custom type (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"user"),") for the object.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To work with the possibility of ",(0,i.kt)("inlineCode",{parentName:"p"},"null")," initial values, use the union type ",(0,i.kt)("inlineCode",{parentName:"p"},"user | null"),", indicating that it can be either a user object or ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When accessing properties of objects that may be ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", consider using optional chaining (",(0,i.kt)("inlineCode",{parentName:"p"},"?."),") to prevent runtime errors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"These practices help ensure type safety when using the ",(0,i.kt)("inlineCode",{parentName:"p"},"useState")," hook in React with TypeScript."))),(0,i.kt)("h3",{id:"-typing-useref-hook"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Typing useRef hook"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"While some React hooks, like ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect"),", may not require explicit typing, others, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"useRef"),", benefit from type annotations.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When using ",(0,i.kt)("inlineCode",{parentName:"p"},"useRef"),", you can create a reference for a native button element, for instance, by passing an initial value of ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To properly type the ref, you can leverage helper types provided by React.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The general ",(0,i.kt)("inlineCode",{parentName:"p"},"element")," type is available, but you can narrow it down to ",(0,i.kt)("inlineCode",{parentName:"p"},"HTML element"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For even more specificity, you can specify that the ",(0,i.kt)("inlineCode",{parentName:"p"},"ref")," will eventually hold an ",(0,i.kt)("inlineCode",{parentName:"p"},"HTMLButtonElement"),", ensuring proper typing.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By applying these type annotations, your ",(0,i.kt)("inlineCode",{parentName:"p"},"ref")," will be correctly typed without the need for ",(0,i.kt)("inlineCode",{parentName:"p"},"| null"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Note that when dealing with the Context API, type annotations can become complex, and it's advisable to refer to dedicated resources for detailed guidance."))),(0,i.kt)("h3",{id:"-using-as-const"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Using ",(0,i.kt)("inlineCode",{parentName:"h3"},"as const")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When working with constants, you can employ the ",(0,i.kt)("inlineCode",{parentName:"p"},"as const")," TypeScript feature to enhance specificity.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Suppose you have a constant array of button text options like "click me," "click me again," and "click me one more time."')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Initially, TypeScript infers this array as an array of strings.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To make it more specific and restrict it to these specific string values, use ",(0,i.kt)("inlineCode",{parentName:"p"},"as const")," after the array.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"as const")," ensures that the array is treated as read-only and contains only the specified string values.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This specificity aids in better type inference, providing you with the actual values when you reference elements from the array.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Furthermore, it prevents accidental additions or modifications to the constant array."))),(0,i.kt)("h3",{id:"-using-the-omit-utility"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Using the ",(0,i.kt)("inlineCode",{parentName:"h3"},"Omit")," Utility"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Suppose you have a ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," type that includes properties like ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"sessionID"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Additionally, you have a ",(0,i.kt)("inlineCode",{parentName:"p"},"guest")," type, which should be similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," but without the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," property.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To achieve this, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Omit")," utility in TypeScript.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"Omit")," takes two arguments: the original type (in this case, ",(0,i.kt)("inlineCode",{parentName:"p"},"user"),") and the property you want to omit (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),").")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When you apply ",(0,i.kt)("inlineCode",{parentName:"p"},"Omit")," in this manner, it creates a new type (",(0,i.kt)("inlineCode",{parentName:"p"},"guest"),") that includes all properties from the original type except the omitted one (",(0,i.kt)("inlineCode",{parentName:"p"},"name"),").")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"As a result, the ",(0,i.kt)("inlineCode",{parentName:"p"},"guest")," type only contains the ",(0,i.kt)("inlineCode",{parentName:"p"},"sessionID")," property and does not include ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),"."))),(0,i.kt)("h3",{id:"-as-type-assertion"},(0,i.kt)("strong",{parentName:"h3"},"=>")," 'as' Type Assertion"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When working with data retrieved from local storage, you often use the ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect")," hook.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"While ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect")," doesn't require typing, there are situations within it where you might need to provide type information.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For instance, when retrieving a value like the previous button color from local storage, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"localStorage.getItem('buttonColor')"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You might already have a type defined for ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonColor"),", such as a union type that represents all possible colors.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, TypeScript infers the result of ",(0,i.kt)("inlineCode",{parentName:"p"},"localStorage.getItem('buttonColor')")," as ",(0,i.kt)("inlineCode",{parentName:"p"},"string | null")," by default.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To tell TypeScript that you expect the result to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonColor"),", you can use a type assertion with the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," keyword.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By asserting the type with ",(0,i.kt)("inlineCode",{parentName:"p"},"as buttonColor"),", you inform TypeScript that you are confident the result is of the specified type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This assertion makes the variable's type consistent with the rest of your application, ensuring that it matches the expected type."))),(0,i.kt)("h3",{id:"-generics-easy"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Generics (EASY!)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In TypeScript, there's a concept called generics, which some people find intimidating but is actually quite straightforward.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's start with a simple example. Imagine we have a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"convertToArray"),", and all it does is take a value and return that value in an array format, enclosed in square brackets.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We want to be able to call this function with different types of values, such as numbers, strings, and booleans.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Currently, TypeScript gives us an error because we haven't specified the type of the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," parameter, so it's inferred as ",(0,i.kt)("inlineCode",{parentName:"p"},"any"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Using ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," is problematic because it allows us to perform operations that might not be safe for all types. For instance, calling ",(0,i.kt)("inlineCode",{parentName:"p"},".toUpperCase()")," on a number will cause issues.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To address this, we could explicitly type ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," as a ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", and we'd also need to specify that the function returns an array of strings. This ensures type safety, but it only works for one specific type, in this case, strings.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, we want this function to work with various types, not just strings. This is where generics come in.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead of hardcoding the type as ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),", we use a generic type parameter, conventionally named ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),". We declare it in angle brackets before the parameter list.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By using ",(0,i.kt)("inlineCode",{parentName:"p"},"T"),", we're making the function more general and allowing it to work with different types.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We specify that the return value will be an array of the same type as the input ",(0,i.kt)("inlineCode",{parentName:"p"},"value"),". This creates a relationship between the parameter and the return value.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"TypeScript will infer ",(0,i.kt)("inlineCode",{parentName:"p"},"T")," based on the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," when we call the function.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To make it cleaner, you can use traditional function syntax and specify the type parameter in front of the parameter list, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"function convertToArray<T>(value: T): T[]"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"With this approach, we can call the function with various types like numbers, strings, and booleans, and TypeScript will handle the type inference correctly.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generics allow us to write more flexible and type-safe functions, making our code more versatile and less error-prone."))),(0,i.kt)("h3",{id:"-generics-in-react"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Generics in React"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generics in React components allow us to handle dynamic types for props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Let's take an example where we have a button component that accepts a ",(0,i.kt)("inlineCode",{parentName:"p"},"countValue")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"countHistory"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We create a type called ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonProps")," to encapsulate these props.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Initially, we could hard-code ",(0,i.kt)("inlineCode",{parentName:"p"},"countValue")," as a number, but we want to make it more flexible, so it can also accept other types like strings.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now, we have a relationship between the type of ",(0,i.kt)("inlineCode",{parentName:"p"},"countValue")," and the type of the elements in the ",(0,i.kt)("inlineCode",{parentName:"p"},"countHistory")," array.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generics are essentially type parameters that let us make our components more versatile.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We specify this relationship between the two props using generics.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To declare a type parameter, we use ",(0,i.kt)("inlineCode",{parentName:"p"},"<T>")," and ensure that ",(0,i.kt)("inlineCode",{parentName:"p"},"countValue")," and the array elements in ",(0,i.kt)("inlineCode",{parentName:"p"},"countHistory")," are of the same type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To use this type parameter, we specify it in angle brackets ",(0,i.kt)("inlineCode",{parentName:"p"},"<T>")," before the parameter list.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, since we've extracted the type into ",(0,i.kt)("inlineCode",{parentName:"p"},"buttonProps"),", we need to add another set of angle brackets when declaring the type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"With this setup, TypeScript will ensure that the ",(0,i.kt)("inlineCode",{parentName:"p"},"countValue")," type matches the type of elements in the ",(0,i.kt)("inlineCode",{parentName:"p"},"countHistory")," array.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If we try to pass mismatched types, TypeScript will generate warnings, helping us maintain type safety in our React components.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generics are a powerful tool in TypeScript for creating flexible and type-safe components. While they may seem complex, they offer significant benefits in maintaining code quality."))),(0,i.kt)("h3",{id:"-indexdts-vs-typests"},(0,i.kt)("strong",{parentName:"h3"},"=>")," ",(0,i.kt)("inlineCode",{parentName:"h3"},"index.d.ts")," vs. ",(0,i.kt)("inlineCode",{parentName:"h3"},"types.ts")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"We've covered some complex topics, but there are a few other essential concepts to grasp.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Consider the example of a color type, like red, blue, and green, which is often part of a theme.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Other components may also require access to this type for styling purposes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To reuse this type across multiple files, it's best to place it in a separate library folder.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You might be tempted to use ",(0,i.kt)("inlineCode",{parentName:"p"},"index.d.ts")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"import type"),", but this is not the recommended approach.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"index.d.ts")," files are primarily used for declaration files that provide type information for third-party libraries.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead, you should create a ",(0,i.kt)("inlineCode",{parentName:"p"},"types.ts")," file to store your custom types and share them across your project."))),(0,i.kt)("h3",{id:"-import-type"},(0,i.kt)("strong",{parentName:"h3"},"=>")," ",(0,i.kt)("inlineCode",{parentName:"h3"},"import type")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Instead of using ",(0,i.kt)("inlineCode",{parentName:"p"},"import type"),", you can create a TypeScript file, let's call it ",(0,i.kt)("inlineCode",{parentName:"p"},"types.ts"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Place your color type definition in this ",(0,i.kt)("inlineCode",{parentName:"p"},"types.ts")," file and export it using ",(0,i.kt)("inlineCode",{parentName:"p"},"export"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Now, you can import this type in other components by using a regular ",(0,i.kt)("inlineCode",{parentName:"p"},"import")," statement.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For example, you can import the color type like this: ",(0,i.kt)("inlineCode",{parentName:"p"},"import { color } from './types';"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By specifying ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," in front of the imported type, you make it explicitly clear that it's a TypeScript type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This helps prevent accidental misuse of the type, treating it as a regular JavaScript variable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The main benefit of this approach is maintaining clarity and ensuring the type is used appropriately."))),(0,i.kt)("h3",{id:"-unknown-type"},(0,i.kt)("strong",{parentName:"h3"},"=>")," 'unknown' type"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Sometimes, you'll encounter the 'unknown' type, which is important to understand.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When using ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect")," to fetch data, you might receive a response, parse it as JSON, and finally, you get the actual data.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"By default, TypeScript types this data as 'any,' but using 'any' is not ideal.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The problem is, when dealing with external APIs, you can't be sure about the structure of the data you'll receive.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It could be different from what you expect, or there could be errors on the server.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To address this uncertainty, TypeScript provides the 'unknown' type, which means you don't know anything about the data.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"You can't immediately use methods or access properties on values of type 'unknown.'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Before using 'unknown' values, you should verify that they have the expected shape and type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This approach helps prevent bugs and ensures you handle unexpected data gracefully."))),(0,i.kt)("h3",{id:"-zod"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Zod"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This is actually where schemas come into place.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Maybe you've heard of Zod and other schema validators.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"What you want to do here is run your data through a schema validator.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In Zod, for example, you can define a schema, then use the ",(0,i.kt)("inlineCode",{parentName:"p"},"parse")," method to check if your data matches that schema.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If the data conforms to the schema, you can proceed with your operations.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Consider replacing occurrences of 'any' with the 'unknown' type and use a schema validator like Zod to ensure the data conforms to the expected shape.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In-depth details about schema validation and using Zod are beyond the scope of this video, but you can find more information in other resources or tutorials."))),(0,i.kt)("h3",{id:"-ts-reset-library"},(0,i.kt)("strong",{parentName:"h3"},"=>")," ts-reset Library"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If you don't want to manually change types from 'any' to 'unknown' yourself, you can consider using the 'ts-reset' package.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This package, created by Met Pook, ensures that when you fetch data, it will automatically be typed as 'unknown'.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The 'ts-reset' package offers other benefits as well, but discussing them is beyond the scope of this video.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"To learn more about installing and using 'ts-reset' and other TypeScript-related topics, you can refer to other videos or courses, such as my course on React and Next.js, where TypeScript and related details are covered."))),(0,i.kt)("h3",{id:"-third-party-types-types--definitelytyped"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Third-party types ('@types' / DefinitelyTyped)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Some other things that you really need to know are the following. Let me clean this up.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Previously, we were actually using a type from React. We did something like ",(0,i.kt)("inlineCode",{parentName:"p"},"children: ReactNode"),", so this is the React namespace, but this is a type that we get from React. We also used one for styles, so we had something like ",(0,i.kt)("inlineCode",{parentName:"p"},"style: React.CSSProperties"),". These are helpful because then we don't have to create these types ourselves; we can just use something from React.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"So, where are these types coming from? Well, if you go into the node_modules folder, you will see something called ",(0,i.kt)("inlineCode",{parentName:"p"},"@types"),". This is where a lot of your third-party library types will come from. Here we also have ",(0,i.kt)("inlineCode",{parentName:"p"},"react"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"react-dom"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"node")," for Node.js. So, ",(0,i.kt)("inlineCode",{parentName:"p"},"@types")," is a repository for high-quality TypeScript type definitions. It's also called DefinitelyTyped, and it's basically a big collection of types for third-party libraries. When Microsoft introduced TypeScript, many of these libraries weren't using TypeScript yet. This project, DefinitelyTyped, provides types for popular third-party libraries like React and many others."))),(0,i.kt)("h3",{id:"-tsconfigjson"},(0,i.kt)("strong",{parentName:"h3"},"=>")," tsconfig.json"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When you're using a framework like Next.js, you'll usually have some other TypeScript files here as well for configuration. Typically, the file you'll always have is a ",(0,i.kt)("inlineCode",{parentName:"p"},"tsconfig.json")," file, where you define TypeScript settings.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"TypeScript compiles your TSX files into JSX files, and you can determine how that should be done using the ",(0,i.kt)("inlineCode",{parentName:"p"},"jsx")," option. This option isn't particularly interesting, and Next.js, by default, sets it to \"preserve.\" You don't typically need to change this.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The only other option here that you may want to use is the ",(0,i.kt)("inlineCode",{parentName:"p"},"strict")," option. In a Next.js project, it's set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," by default. This means that TypeScript will enforce strict type checking.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"As a quick example, if you remember when we had a state that's initially ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", like ",(0,i.kt)("inlineCode",{parentName:"p"},"const [user, setUser] = useState(null);"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," can be an object with properties like ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"email"),", TypeScript will give you a red squiggly line if you try to access properties of ",(0,i.kt)("inlineCode",{parentName:"p"},"user")," because it could possibly be ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"However, if you set ",(0,i.kt)("inlineCode",{parentName:"p"},"strict")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", the red squiggly line disappears. So, it's less strict. But it's generally better to be strict with your types and make sure you handle null values properly, either with optional chaining or checking for null values.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"strict")," setting doesn't only affect this behavior; it also affects other type checking rules. In general, it's a good idea to be strict with your TypeScript settings, but usually, your framework will have already set these settings for you, so you don't need to change them."))),(0,i.kt)("h3",{id:"-next-envdts"},(0,i.kt)("strong",{parentName:"h3"},"=>")," next-env.d.ts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"In Next.js specifically, we also have this ",(0,i.kt)("inlineCode",{parentName:"p"},"next-env.d.ts")," file, and this file references the types for Next.js. If we're using some Next.js-specific feature, we also want to ensure we get correct typing, and this file ensures that.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"As a quick example, if you're fetching data in a server component in Next.js, you can do that using the ",(0,i.kt)("inlineCode",{parentName:"p"},"fetch")," function to some URL. What's unique in Next.js is that they have extended the ",(0,i.kt)("inlineCode",{parentName:"p"},"fetch")," API a bit. Instead of just a plain URL, you can write ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," here, and this is actually an object. When you start typing inside this object, you'll get intelligent code suggestions. For instance, it suggests that you can pass properties like ",(0,i.kt)("inlineCode",{parentName:"p"},"revalidate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"text"),". If you try to pass something that's not the correct type, you'll get a warning. In this case, it should be a number.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"This is a Next.js-specific feature where they have extended the ",(0,i.kt)("inlineCode",{parentName:"p"},"fetch")," API to provide additional functionality and typing. The reason you get this typing and intelligence is because you include this ",(0,i.kt)("inlineCode",{parentName:"p"},"next-env.d.ts")," file, which references where those types for Next.js are defined.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"There was a lot to take in, and it's completely normal if you're a little bit confused right now."))))}c.isMDXComponent=!0}}]);