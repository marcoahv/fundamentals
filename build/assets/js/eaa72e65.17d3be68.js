"use strict";(self.webpackChunkfundamentals=self.webpackChunkfundamentals||[]).push([[631],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=c(n),m=i,d=h["".concat(s,".").concat(m)]||h[m]||p[m]||o;return n?a.createElement(d,r(r({ref:t},u),{},{components:n})):a.createElement(d,r({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2629:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:3},r="Asynchronous JavaScript",l={unversionedId:"3 JavaScript/3 Asynchronous JavaScript",id:"3 JavaScript/3 Asynchronous JavaScript",title:"Asynchronous JavaScript",description:"=> Why async JavaScript is important",source:"@site/docs/3 JavaScript/3 Asynchronous JavaScript.md",sourceDirName:"3 JavaScript",slug:"/3 JavaScript/3 Asynchronous JavaScript",permalink:"/fundamentals/3 JavaScript/3 Asynchronous JavaScript",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Advanced JavaScript",permalink:"/fundamentals/3 JavaScript/2 Advanced JavaScript"},next:{title:"JavaScript Tools",permalink:"/fundamentals/3 JavaScript/5 JavaScript Tools"}},s={},c=[{value:"<strong>=&gt;</strong> Why async JavaScript is important",id:"-why-async-javascript-is-important",level:3},{value:"Introduction",id:"introduction",level:4},{value:"Synchronous, Blocking, Single-Threaded JavaScript",id:"synchronous-blocking-single-threaded-javascript",level:4},{value:"Challenges of Synchronous JavaScript",id:"challenges-of-synchronous-javascript",level:4},{value:"Asynchronous Programming in JavaScript",id:"asynchronous-programming-in-javascript",level:4},{value:"Conclusion",id:"conclusion",level:4},{value:"<strong>=&gt;</strong> Timeouts and Intervals",id:"-timeouts-and-intervals",level:3},{value:"Timeouts and Intervals",id:"timeouts-and-intervals",level:4},{value:"setTimeout",id:"settimeout",level:4},{value:"Clearing Timeouts",id:"clearing-timeouts",level:4},{value:"setInterval",id:"setinterval",level:4},{value:"Additional Points",id:"additional-points",level:4},{value:"Conclusion",id:"conclusion-1",level:4},{value:"<strong>=&gt;</strong> Callbacks",id:"-callbacks",level:3},{value:"<strong>=&gt;</strong> Promise",id:"-promise",level:3},{value:"JavaScript Analogy",id:"javascript-analogy",level:4},{value:"Why Use Promises",id:"why-use-promises",level:4},{value:"Working with Promises",id:"working-with-promises",level:4},{value:"Creating a Promise",id:"creating-a-promise",level:4},{value:"Fulfilling or Rejecting a Promise",id:"fulfilling-or-rejecting-a-promise",level:4},{value:"Executing Callback Functions",id:"executing-callback-functions",level:4},{value:"Interview Tips",id:"interview-tips",level:4},{value:"Chaining Promises",id:"chaining-promises",level:4},{value:"Chaining Promises",id:"chaining-promises-1",level:4},{value:"<strong>=&gt;</strong> Static Methods",id:"-static-methods",level:3},{value:"<strong>=&gt;</strong> Async &amp; Await",id:"-async--await",level:3},{value:"The async Keyword",id:"the-async-keyword",level:4},{value:"The await Keyword",id:"the-await-keyword",level:4},{value:"<strong>=&gt;</strong> Event Loop",id:"-event-loop",level:3},{value:"Recap of Async Programming in JavaScript",id:"recap-of-async-programming-in-javascript",level:4},{value:"Synchronous Code Execution",id:"synchronous-code-execution",level:4},{value:"Conclusion",id:"conclusion-2",level:4}],u={toc:c},h="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(h,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"asynchronous-javascript"},"Asynchronous JavaScript"),(0,i.kt)("h3",{id:"-why-async-javascript-is-important"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Why async JavaScript is important"),(0,i.kt)("h4",{id:"introduction"},"Introduction"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We need to understand the basics of async programming and why async JavaScript is important."),(0,i.kt)("li",{parentName:"ul"},"Under this topic, we have a few concepts to cover from an interview point of view: timeouts and intervals, callbacks, promises, async/await, and the all-important event loop."),(0,i.kt)("li",{parentName:"ul"},"If you are a junior dev applying for an interview, a surface knowledge of these topics will suffice. However, if you are applying for a more senior role, you're expected to have a deeper understanding of all these topics."),(0,i.kt)("li",{parentName:"ul"},'In this lecture, we are going to understand the "what" and "why" of async JavaScript. In the upcoming videos, we will see the "how" of async JavaScript by understanding and solving exercise problems on timeouts, callbacks, promises, and async/await.'),(0,i.kt)("li",{parentName:"ul"},"We will wind up async JavaScript by understanding how all of them behave with respect to the event loop.")),(0,i.kt)("h4",{id:"synchronous-blocking-single-threaded-javascript"},"Synchronous, Blocking, Single-Threaded JavaScript"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"JavaScript, in its most basic form, is a synchronous, blocking, single-threaded language."),(0,i.kt)("li",{parentName:"ul"},"These three points are crucial. Let's understand what they mean.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"JavaScript is synchronous, meaning that code executes top-down with only one line executing at any given time."),(0,i.kt)("li",{parentName:"ul"},"JavaScript is blocking, which means that subsequent processes won't start until the previous one is completed."),(0,i.kt)("li",{parentName:"ul"},"JavaScript is single-threaded, having just one thread, the main thread, for executing code.")))),(0,i.kt)("h4",{id:"challenges-of-synchronous-javascript"},"Challenges of Synchronous JavaScript"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This model of JavaScript creates a significant problem, especially when we have tasks that require waiting, like retrieving data from a database."),(0,i.kt)("li",{parentName:"ul"},"We need a way to have asynchronous behavior in JavaScript.")),(0,i.kt)("h4",{id:"asynchronous-programming-in-javascript"},"Asynchronous Programming in JavaScript"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"To cater to asynchronous programming in JavaScript, we rely on functions and APIs defined by web browsers."),(0,i.kt)("li",{parentName:"ul"},"These functions and APIs allow us to register functions that should not be executed synchronously but should be invoked asynchronously when some event occurs (e.g., the passage of time, user interactions, or data arrival over the network)."),(0,i.kt)("li",{parentName:"ul"},"This enables running multiple tasks simultaneously without blocking the main thread.")),(0,i.kt)("h4",{id:"conclusion"},"Conclusion"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"JavaScript's synchronous, blocking, and single-threaded nature necessitates the use of asynchronous techniques."),(0,i.kt)("li",{parentName:"ul"},"Web browsers provide functions and APIs to enable asynchronous behavior in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"In the next lecture, we will explore the traditional methods JavaScript offers for running code asynchronously.")),(0,i.kt)("h3",{id:"-timeouts-and-intervals"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Timeouts and Intervals"),(0,i.kt)("h4",{id:"timeouts-and-intervals"},"Timeouts and Intervals"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In this lecture, let's look at the traditional methods JavaScript has available for running code asynchronously after a set time period elapsed or at regular intervals of time."),(0,i.kt)("li",{parentName:"ul"},"In other words, let's look at the ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," function and the ",(0,i.kt)("inlineCode",{parentName:"li"},"setInterval")," function.")),(0,i.kt)("h4",{id:"settimeout"},"setTimeout"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," function executes a particular block of code once after a specified time has elapsed."),(0,i.kt)("li",{parentName:"ul"},"Parameters:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The first parameter is a function to run or a reference to a function defined elsewhere."),(0,i.kt)("li",{parentName:"ul"},"The second parameter is a number representing the duration in milliseconds to wait before executing the code."))),(0,i.kt)("li",{parentName:"ul"},"You can pass zero or more values after the duration as parameters for the function."),(0,i.kt)("li",{parentName:"ul"},"Example: If we have a function ",(0,i.kt)("inlineCode",{parentName:"li"},"greet"),' that logs "hello" to the console, we can pass it into ',(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," with a duration of two seconds."),(0,i.kt)("li",{parentName:"ul"},"To cancel a timeout, use ",(0,i.kt)("inlineCode",{parentName:"li"},"clearTimeout")," with the identifier returned by ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout"),".")),(0,i.kt)("h4",{id:"clearing-timeouts"},"Clearing Timeouts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A more practical scenario is clearing timeouts when the component is unmounting to free up resources and prevent code from executing on an unmounted component.")),(0,i.kt)("h4",{id:"setinterval"},"setInterval"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"setInterval")," is used to repeatedly run the same code at regular intervals."),(0,i.kt)("li",{parentName:"ul"},"The signature is similar to ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout"),": first parameter is the code to execute, the second parameter is the duration in milliseconds, and zero or more arguments for the passed-in function."),(0,i.kt)("li",{parentName:"ul"},"Example: Function ",(0,i.kt)("inlineCode",{parentName:"li"},"greet"),' is called every two seconds, logging "hello" to the console.'),(0,i.kt)("li",{parentName:"ul"},"You should clear intervals when appropriate using ",(0,i.kt)("inlineCode",{parentName:"li"},"clearInterval")," by capturing the return value from ",(0,i.kt)("inlineCode",{parentName:"li"},"setInterval"),".")),(0,i.kt)("h4",{id:"additional-points"},"Additional Points"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Timers and intervals are not part of JavaScript itself; they are implemented by the browser, and ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"setInterval")," are names given to that functionality in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"The duration parameter is the minimum delay, not guaranteed. JavaScript will execute the function when the specified time has elapsed and the call stack is free."),(0,i.kt)("li",{parentName:"ul"},"Recursive ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," versus ",(0,i.kt)("inlineCode",{parentName:"li"},"setInterval"),": Recursive ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," guarantees the same interval between executions, while ",(0,i.kt)("inlineCode",{parentName:"li"},"setInterval")," considers the time taken to execute the code, potentially leading to varying intervals. Recursive ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," offers more flexibility in choosing different intervals for each iteration.")),(0,i.kt)("h4",{id:"conclusion-1"},"Conclusion"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"With a good understanding of ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"setInterval"),", in the next lecture, we will delve into essential exercise problems from an interview perspective.")),(0,i.kt)("h3",{id:"-callbacks"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Callbacks"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Welcome back! In this lecture, we are going to learn about callbacks in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"Let's begin by understanding an important point: in JavaScript, functions are first-class objects. What that means is that, just like an object, a function can be passed as an argument to a function, and a function can also be returned as values from other functions."),(0,i.kt)("li",{parentName:"ul"},"Let's understand this with a simple example:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"I have a function called ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," which accepts a ",(0,i.kt)("inlineCode",{parentName:"li"},"name"),' parameter and logs to the console "hello" followed by ',(0,i.kt)("inlineCode",{parentName:"li"},"name"),"."),(0,i.kt)("li",{parentName:"ul"},"I then have another function called ",(0,i.kt)("inlineCode",{parentName:"li"},"greetVishwas"),". What is special here is that the function accepts another function as its argument. Within the function body, we have a ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," declaration ",(0,i.kt)("inlineCode",{parentName:"li"},"name"),' equal to "vishwas," and we call the passed-in function with ',(0,i.kt)("inlineCode",{parentName:"li"},"name")," as its argument."),(0,i.kt)("li",{parentName:"ul"},"Finally, we invoke ",(0,i.kt)("inlineCode",{parentName:"li"},"greetVishwas")," passing in the `greet")))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"function. So, the control goes to"),"greetVishwas",(0,i.kt)("inlineCode",{parentName:"p"},", which calls "),"greetFn",(0,i.kt)("inlineCode",{parentName:"p"},". "),"greetFn",(0,i.kt)("inlineCode",{parentName:"p"},"is nothing but the"),"greet",(0,i.kt)("inlineCode",{parentName:"p"},"function we have defined here. So, execution goes to the"),"greet",(0,i.kt)("inlineCode",{parentName:"p"},"function with"),'name` equals "vishwas," and "hello vishwas" is logged to the console.'),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"So, ",(0,i.kt)("inlineCode",{parentName:"li"},"greetVishwas")," is a function that accepts another function as an argument, and you might be pleasantly surprised to learn that any function that is passed as an argument to another function is called a ",(0,i.kt)("strong",{parentName:"li"},"callback function")," in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"Also, the function which accepts a function as an argument or returns a function is called a ",(0,i.kt)("strong",{parentName:"li"},"higher-order function"),"."),(0,i.kt)("li",{parentName:"ul"},"If I simply rename the function and its argument to convey what they stand for on line 5, we have ",(0,i.kt)("inlineCode",{parentName:"li"},"higherOrderFunction")," which accepts a ",(0,i.kt)("inlineCode",{parentName:"li"},"callbackFunction"),", and then on line 7, calls that callback function passing in the ",(0,i.kt)("inlineCode",{parentName:"li"},"name")," constant."),(0,i.kt)("li",{parentName:"ul"},"So, we now know what a callback function is. You might be thinking, is that it? Well, yes, a function passed as an argument to another function is called a callback function."),(0,i.kt)("li",{parentName:"ul"},"But what we need to understand is why do we need a callback function? We can answer that by categorizing callbacks into two: synchronous callbacks and asynchronous callbacks."),(0,i.kt)("li",{parentName:"ul"},"Let's first talk about synchronous callbacks:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A callback which is executed immediately is called a synchronous callback. The ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," callback function from earlier is an example because the function gets executed immediately when the control goes inside the higher-order function."),(0,i.kt)("li",{parentName:"ul"},"A more practical example is a callback function passed to methods like ",(0,i.kt)("inlineCode",{parentName:"li"},"sort"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"map"),", or ",(0,i.kt)("inlineCode",{parentName:"li"},"filter"),". In these cases, the callback function defines the logic that the higher-order function needs to apply. So, nothing too fancy when it comes to synchronous callbacks."))),(0,i.kt)("li",{parentName:"ul"},"Let's now move on to asynchronous callbacks, which will also bring our focus back on asynchronous JavaScript:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"An asynchronous callback is a callback that is often used to continue or resume code execution after an asynchronous operation has completed."),(0,i.kt)("li",{parentName:"ul"},"So, in the async world, callbacks are used to delay the execution of a function until a particular time or event has occurred, and this use case is really important because most of the applications that we build usually have some sort of data to be fetched. We all know that data fetching takes time, and we can only run the function we want to after the data has been fetched and not immediately."))),(0,i.kt)("li",{parentName:"ul"},"Let's take a look at a few examples of async callbacks which you might already be using without knowing that they're callback functions:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The first example is that of ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout"),", which we recently learned here. ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," acts as the higher-order function, and ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," is the callback function. When the thread of execution goes through line number 5, does the ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," function execute immediately? No, it waits for two seconds and then executes the ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," callback function, making it an async callback."),(0,i.kt)("li",{parentName:"ul"},"Another common usage is event handlers. When JavaScript encounters line number 5, it does not immediately run the callback function. The function is only run when the user clicks on the button."),(0,i.kt)("li",{parentName:"ul"},"If you want a data fetching example with callbacks, you can go back to jQuery if you've used it before. ",(0,i.kt)("inlineCode",{parentName:"li"},"$.get")," and the first parameter is the URL, and the second parameter is the callback function, which gets called only after the data has been loaded."))),(0,i.kt)("li",{parentName:"ul"},"This is the role that callback functions play in async JavaScript. They allow you to delay the execution of a function. Callbacks are something you're going to heavily see in Node.js. However, there is a problem with the callbacks pattern. If you have multiple callback functions where each level depends on the result obtained from the previous level, the nesting of functions becomes so deep that the code becomes difficult to read and maintain."),(0,i.kt)("li",{parentName:"ul"},"In the code snippet here, you can see that each inner function depends on the result obtained from the outer function. So, once you go several levels deep like on line 5, the nesting starts to confuse you. The code is just not intuitive and only gets worse with more and more callback functions."),(0,i.kt)("li",{parentName:"ul"},'As the application grows, to tackle this problem of "callback hell," promises were introduced in ES6, which we will learn about in the next lecture.'),(0,i.kt)("li",{parentName:"ul"},"But let me summarize about callbacks from an interview point of view:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Callbacks are functions passed as arguments to other functions. They can be synchronous if they execute immediately or they can be asynchronous, where they get executed after some time has passed, some event has occurred, or some data has been fetched."),(0,i.kt)("li",{parentName:"ul"},'Callbacks were the go-to pattern for asynchronously running code after fetching some data. However, as more and more requests had to be made based on the data obtained from the previous requests, developers started to encounter what is known as the "callback hell."'),(0,i.kt)("li",{parentName:"ul"},"Callback hell makes the code difficult to reason about. An alternative and the recommended approach now is to use promises. Let's learn about that in the next lecture.")))),(0,i.kt)("h3",{id:"-promise"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Promise"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In this lecture, we are going to learn about promises in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"Here is a useful piece of info: In about eighty percent of the interviews I appeared for, I was asked about promises. So, if you're appearing for a senior dev position, you can take it for granted that you will be asked about this topic. So, make sure you have a thorough understanding of promises in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"I want to begin by helping you understand promises with a simple analogy. Once you understand the big picture in simple layman terms, we will then move on to understanding promises in JavaScript.")),(0,i.kt)("p",null,"Consider a scenario where you and your roommate want to have dinner at home:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You want to prepare your special soup."),(0,i.kt)("li",{parentName:"ul"},"At the same time, you feel like having tacos from the food truck nearby."),(0,i.kt)("li",{parentName:"ul"},'So, you ask your roommate, "Hey, can you go down to the food truck and get us some tacos?"'),(0,i.kt)("li",{parentName:"ul"},"Your friend says, \"Sure.\" And when he's about to leave, you tell him there is no point in me waiting until you're back to prepare the soup, so I'll start with the soup now. But when you reach the place, can you promise that you'll text me so that I can start setting up the dining table? Also, let me know if something goes wrong. If you can't find the food truck or if they're out of tacos for the night, whatever might be the reason, just let me know that you cannot get the tacos, and I'll start cooking some pasta instead."),(0,i.kt)("li",{parentName:"ul"},'Your friend says, "Sure, I promise. I\'ll head out now and text you in some time."')),(0,i.kt)("p",null,"Now, you go about preparing your soup, but the status on tacos, we can say that it is currently pending till you receive that message from your friend. When you get back a text message saying that he is getting the tacos, your desire to eat tacos has been fulfilled, and you can then proceed to set up the dining table. If the text message says that he cannot bring back any tacos, your desire to have tacos has been rejected, and now you have to cook some pasta instead."),(0,i.kt)("h4",{id:"javascript-analogy"},"JavaScript Analogy"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Now, let's pick the important bits from the scenario and relate it back to JavaScript and promises. In the scenario:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Your friend is like a promise in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"While your friend is on his way to the food truck, you know that it could take a while, and you don't want to sit idle, so you start preparing soup. In the meantime, this part is an analogy to an asynchronous operation in JavaScript."),(0,i.kt)("li",{parentName:"ul"},'Fetch tacos: When your friend texts you with "can get tacos" or "can\'t get tacos," it answers your question on whether he\'s getting the tacos or not. In JavaScript, this is the promise return value. If the return value is "can get tacos," the promise is said to be fulfilled. If the return value is "cannot get tacos," for whatever might be the reason, the promise is said to be rejected.'),(0,i.kt)("li",{parentName:"ul"},"If the promise is fulfilled, you can set up the dining table. This is a success callback, or in other words, it is the callback function that gets executed when the promise is resolved successfully."),(0,i.kt)("li",{parentName:"ul"},"If the promise is rejected, you can cook some pasta. This is the failure callback, or in other words, it is the callback function that gets executed when the promise failed to resolve and was rejected instead.")))),(0,i.kt)("p",null,"That pretty much is a high-level overview of what a promise is in JavaScript. Let's read through the MDN definition of a promise:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A promise is a proxy for a value, not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason.")),(0,i.kt)("p",null,"To understand this definition better, let's break it down:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A promise is a proxy for a value. Going back to our example, your friend made a promise that he will let you know whether he can or cannot get tacos, which is the promise value. The promise value is not necessarily known when the promise is created. In our example, you don't know which one of them is the value when your friend made his promise (he can get tacos or cannot get tacos); you don't necessarily know that value."),(0,i.kt)("li",{parentName:"ul"},"A promise allows you to associate handlers with an asynchronous action's eventual success value or failure reason. Based on the promise value, you could decide ahead of time what has to be done when the promise is eventually fulfilled or rejected\u2014that is, either setting up the table or cooking pasta.")),(0,i.kt)("p",null,"Technically, a promise is simply an object in JavaScript, and a promise is always in one of the three states: pending (initial state, neither fulfilled nor rejected), fulfilled (the operation completed successfully), and rejected (the operation failed)."),(0,i.kt)("h4",{id:"why-use-promises"},"Why Use Promises"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Why would you use a promise? Well, for one and only one purpose: Promises help us deal with asynchronous code in a far simpler way compared to callbacks. Remember the callback hell we spoke about in the previous lecture? Well, that can be avoided with promises, and the code can be sort of read in a simple synchronous way. You'll see this in just a bit when we take a look at an example.")),(0,i.kt)("p",null,'That is the "what" and "why" about promises. Next, let\'s see how to work with promises in JavaScript.'),(0,i.kt)("h4",{id:"working-with-promises"},"Working with Promises"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'If you go back to our example, we have your friend as an analogy for a promise, "can get tacos" or "cannot get tacos," which is the promised value that your friend should inform you about. If he can get tacos, he\'s fulfilling his promise. If he cannot get tacos, he is rejecting his promise. And we have the success callback and the failure callback that we need to attach to the result returned by the promise, either set up the table or cook pasta.')),(0,i.kt)("p",null,"Now, these six points cover the necessary information about a promise. So now, we need to understand three things in code:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"How to create a promise (which covers point number one)."),(0,i.kt)("li",{parentName:"ol"},"How to fulfill or reject the promise (which covers points two, three, and four)."),(0,i.kt)("li",{parentName:"ol"},"How to execute callback functions based on whether the promise is fulfilled or rejected (which covers points 5 and 6).")),(0,i.kt)("p",null,"Let's go over them one by one, starting with how to create a promise."),(0,i.kt)("h4",{id:"creating-a-promise"},"Creating a Promise"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We create an instance of a promise using the ",(0,i.kt)("inlineCode",{parentName:"li"},"new")," keyword with the ",(0,i.kt)("inlineCode",{parentName:"li"},"Promise")," constructor function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const promise = new Promise((resolve, reject) => {\n  // Your asynchronous code here\n})\n")))),(0,i.kt)("h4",{id:"fulfilling-or-rejecting-a-promise"},"Fulfilling or Rejecting a Promise"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"Promise")," constructor function accepts one function as its argument. Let's pass in an arrow function."),(0,i.kt)("li",{parentName:"ul"},"This arrow function automatically receives two arguments: ",(0,i.kt)("inlineCode",{parentName:"li"},"resolve")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"reject"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"resolve")," is a function that, when called, changes the status of the promise from pending to fulfilled."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"reject")," is a function that, when called, changes the status of the promise to rejected."),(0,i.kt)("li",{parentName:"ul"},"You cannot directly mutate the status of a promise; you can call the ",(0,i.kt)("inlineCode",{parentName:"li"},"resolve")," function to fulfill the promise or the ",(0,i.kt)("inlineCode",{parentName:"li"},"reject")," function to reject the promise.")),(0,i.kt)("p",null,"To keep things simple, let's use a ",(0,i.kt)("inlineCode",{parentName:"p"},"setTimeout"),". We"),(0,i.kt)("p",null,"'re going to assume that for your friend to go out and text you back, it takes five seconds. So, our code now changes to incorporate the ",(0,i.kt)("inlineCode",{parentName:"p"},"setTimeout"),". If the food truck was found, we will call ",(0,i.kt)("inlineCode",{parentName:"p"},"resolve")," after five seconds; if the food truck was not found, we call ",(0,i.kt)("inlineCode",{parentName:"p"},"reject")," after five seconds."),(0,i.kt)("h4",{id:"executing-callback-functions"},"Executing Callback Functions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The final part is to understand how to execute callback functions based on the status change of the promise."),(0,i.kt)("li",{parentName:"ul"},"Let's define two callback functions:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onFulfillment"),": The function to be called if ",(0,i.kt)("inlineCode",{parentName:"li"},"resolve")," is called after the async operation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"onRejection"),": The function to be called if ",(0,i.kt)("inlineCode",{parentName:"li"},"reject")," is called after the async operation.")))),(0,i.kt)("p",null,"In our analogy, if the food truck was found and our promise is fulfilled, in which case we want to set up the table to eat tacos. If the food truck was not found and our promise is rejected, we have to start cooking the pasta. We've turned those actions into log statements."),(0,i.kt)("p",null,"Ideally, there would be more code in your callback functions, but we're simply logging to the console, and it serves the purpose. Now, I keep telling you that we are defining callback functions, but callback functions are functions that are passed in as arguments to other functions, right? Well, where are those other functions? This is the point where the promise we have created comes into picture. When we create a new promise using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise")," constructor function, the promise object gives us access to two methods or functions, ",(0,i.kt)("inlineCode",{parentName:"p"},"then")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"catch"),". We call those functions using ",(0,i.kt)("inlineCode",{parentName:"p"},"promise.then")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"promise.catch"),", as you can see on lines 18 and 19. But here's the important bit: If the status of the promise changes from pending to fulfilled by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"resolve")," function, the function that is passed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"then")," function will automatically get invoked. And if the status of the promise changes from pending to rejected by calling the ",(0,i.kt)("inlineCode",{parentName:"p"},"reject")," function, the function that is passed to the ",(0,i.kt)("inlineCode",{parentName:"p"},"catch")," function will automatically get invoked. In our case, we need to pass the ",(0,i.kt)("inlineCode",{parentName:"p"},"onFulfillment")," function to ",(0,i.kt)("inlineCode",{parentName:"p"},"then")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"onRejection")," function to ",(0,i.kt)("inlineCode",{parentName:"p"},"catch"),". Since the two functions are passed in as arguments to other functions, they are callback functions. Hopefully, that makes sense now. Our promise code works as expected, but there is room for improvement."),(0,i.kt)("p",null,"What if we want to send out some data when resolving or rejecting a promise? That way, inside our callback functions, we can make use of the value to do something else. Well, it turns out that we can do that by passing an argument to ",(0,i.kt)("inlineCode",{parentName:"p"},"resolve")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"reject"),". For the ",(0,i.kt)("inlineCode",{parentName:"p"},"resolve"),' function on line 6, we\'ll pass in a string that says "bringing tacos," and for ',(0,i.kt)("inlineCode",{parentName:"p"},"reject"),' on line 40, I\'ll pass in a string that says "not bringing tacos, food truck not there." But how do we access these strings in our callback functions? Well, the great thing about a promise is that it will automatically inject the argument passed to ',(0,i.kt)("inlineCode",{parentName:"p"},"resolve")," as the argument to the ",(0,i.kt)("inlineCode",{parentName:"p"},"onFulfillment")," callback and the argument passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"reject")," as the argument to the ",(0,i.kt)("inlineCode",{parentName:"p"},"onRejection"),' callback. You can see that I\'ve included parameters to both these callbacks and simply log them to the console on lines three and line nine. So we would now see the output "bringing tacos" and "set up the table to eat tacos" from lines three and four when the promise is fulfilled, or if there is an error and hence a rejection, we would see "not bringing tacos" and "start cooking pasta" from lines nine and 10. Of course, in a practical scenario, your result would be an object or an array or any data type that your async operation returns, and the error might be an object with different error codes. In your on rejection callback handler, you might want to perform different actions based on the error status code. But this pretty much is the fundamentals of promises in JavaScript.'),(0,i.kt)("h4",{id:"interview-tips"},"Interview Tips"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"During an interview, begin by explaining what a promise is. You don't have to give the technical definition from MDN; it's probably better to explain in your own words."),(0,i.kt)("li",{parentName:"ul"},"Talk about how promises are used for async operations in JavaScript. Give an analogy to a real-world scenario and connect it back to JavaScript."),(0,i.kt)("li",{parentName:"ul"},"Talk about the three states that a promise can be in, namely pending, fulfilled, and rejected."),(0,i.kt)("li",{parentName:"ul"},"Talk about the function that is passed into the promise constructor function."),(0,i.kt)("li",{parentName:"ul"},"Talk about the ",(0,i.kt)("inlineCode",{parentName:"li"},"resolve")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"reject")," functions and how they change the state of the promise from pending to fulfilled or pending to rejected."),(0,i.kt)("li",{parentName:"ul"},"Finally, talk about the on fulfillment and on rejection callback functions, which let you decide what to run when a promise is either fulfilled or rejected.")),(0,i.kt)("p",null,"If you're applying for a junior dev role, for the most part, this should give the interviewer a good impression of your knowledge of promises. However, there are a few more details for us to understand. We will do that in the next lecture, which is part two of promises. In the previous lecture, we learned the fundamentals of promises in JavaScript. We learned how to create a promise, how to change its state using the resolve and reject functions, and also how to attach callbacks using then and catch functions on the promise object. In this lecture, let's understand a few more points around the concept of promises, which are useful during an interview."),(0,i.kt)("h4",{id:"chaining-promises"},"Chaining Promises"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"At the moment, we pass in the on fulfillment callback to then function and on rejection callback to catch function. But you could, if you want to, pass on rejection as a second argument to the then function. The code works exactly as before; however, the usage of the catch function is encouraged because of one main reason. In the below two-argument approach, the on rejection callback handles errors from only the promise. However, if your callback function itself throws an error or an exception, there is no code to handle that. If you have a catch function, though, even if your on fulfillment callback throws an exception, it is still caught, and then you can handle that exception gracefully. So do make a note that the then function can accept both success and error callbacks, but it's not preferred over using the catch function.")),(0,i.kt)("h4",{id:"chaining-promises-1"},"Chaining Promises"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Another aspect to understand is chaining promises. At the moment, a promise is returned by using the new keyword followed by the promise constructor function. But let me tell you that both then and catch methods return promises. This means then and catch methods can be chained in JavaScript. So, the two lines on line 5 and 6 can be rewritten as ",(0,i.kt)("inlineCode",{parentName:"li"},"promise.then(onFulfillment).catch(onRejection)"),", and this chaining can be done as many times as you want. This also solves the problem of callback hell we encountered a few lectures back. So the code with callbacks looked like this, and the same code with promises looks like this. As you can see, the code becomes much more readable and maintainable. In fact, it seems as if the code is synchronous. We begin by fetching the current user, then fetch the followers, then fetch their interests, then fetch their tags, then fetch the description, and then finally display the data. This is really important to keep in mind not only from an interview point of view but also for your day-to-day work. Promises can be chained.")),(0,i.kt)("h3",{id:"-static-methods"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Static Methods"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The last point to discuss when it comes to promises for an interview is some of the static methods available with a promise. The first one is the ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all")," static method. Many times you may want to query multiple APIs and perform some actions but only after all the APIs have finished loading. For such scenarios, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all"),". Here's a good example from MDN docs to help you better understand this method. In the example we have here, the first promise immediately results; the second isn't really a promise, and the third results after 100 milliseconds. You can pass in all three promises as an array to ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all"),", and you see the output as an array containing the results of the individual promises. However, please do keep in mind even if one of the promises rejects, ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all")," will reject with that error message. So, this example can be summarized into the following points:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"Promise.all")," method takes an iterable of promises as an input and returns a single promise that results in an array of the results of the input promises."),(0,i.kt)("li",{parentName:"ul"},"The return promise will resolve when all of the input's promises have been resolved or if the input iterable contains no promises. However, it rejects immediately if any of the input promises reject or the non-promises throw an error and will reject with the first rejection message or error."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A slight variation of ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.allSettled"),", which waits for all input promises to complete regardless of whether or not one of them is rejected. So, ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all")," returns even if one promise rejects, whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.allSettled")," returns after all promises have completed, even if one or more promises reject.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The next method is ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.race"),". This method returns a promise that fulfills or rejects as soon as one of the promises fulfills or rejects with the value or reason from that promise. In the example we have here, even though both promises resolve, promise 2 results in 100 milliseconds, whereas promise 1 results in 500 milliseconds. So the value result from promise 2 is the value ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.race"),' will get, which is logged to the console on line 10. The output is the string "2" that you can see here.'))),(0,i.kt)("p",null,"So, ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.allSettled"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.race")," are some of the static methods to keep in mind for an interview."),(0,i.kt)("p",null,"Well, with that, we come to the end of the discussion about promises in JavaScript. In the next lecture, let's take a look at how asynchronous code can be further improved with async/await."),(0,i.kt)("h3",{id:"-async--await"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Async & Await"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Welcome back. In the previous two lectures, we learned about promises in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"We learned about the basic syntax and how to add success and failure callbacks."),(0,i.kt)("li",{parentName:"ul"},"We also learned how chaining promises resolves the problem we had with callback hell."),(0,i.kt)("li",{parentName:"ul"},"Although it's clear that promises improve the readability of your asynchronous code, there is a way to improve it even further, that is by using the ",(0,i.kt)("inlineCode",{parentName:"li"},"async")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," keywords introduced in ES2017."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"async")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," keywords allow us to write completely synchronous-looking code while performing asynchronous tasks behind the scenes. In this lecture, let's understand more about ",(0,i.kt)("inlineCode",{parentName:"li"},"async")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"await"),".")),(0,i.kt)("h4",{id:"the-async-keyword"},"The async Keyword"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"async")," keyword is used to declare async functions."),(0,i.kt)("li",{parentName:"ul"},"What are async functions? Async functions are functions that are instances of the ",(0,i.kt)("inlineCode",{parentName:"li"},"async")," function constructor."),(0,i.kt)("li",{parentName:"ul"},"Now, what is special about async functions? Well, unlike normal functions, async functions always return a promise."),(0,i.kt)("li",{parentName:"ul"},"Let's understand this with an example:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Here you can see that we have a simple normal function ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," which returns ",(0,i.kt)("inlineCode",{parentName:"li"},'"hello"'),"."),(0,i.kt)("li",{parentName:"ul"},'When you run this function in the browser console, it logs "hello," nothing that we don\'t already know.'),(0,i.kt)("li",{parentName:"ul"},"Let's convert this function into an async function:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"async function greet() {\n  return 'hello'\n}\n"))),(0,i.kt)("li",{parentName:"ul"},'If you run this function in the browser console, you\'re going to see "promise fulfilled" followed by "hello" logged.'),(0,i.kt)("li",{parentName:"ul"},'"Fulfilled" is the promise status, and "hello" is the promise value.'))),(0,i.kt)("li",{parentName:"ul"},"Like I mentioned, an async function always returns a promise. If you don't explicitly return a promise, the async function will automatically wrap the value in a resolved promise."),(0,i.kt)("li",{parentName:"ul"},"So, you could, if you wanted to, rewrite the function body as:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"async function greet() {\n  return Promise.resolve('hello')\n}\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The output would be the same."))),(0,i.kt)("li",{parentName:"ul"},"In order to actually consume the string value when the promise fulfills, we would use the ",(0,i.kt)("inlineCode",{parentName:"li"},"then")," function on the promise instance:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"greet().then(value => {\n  console.log(value)\n})\n"))),(0,i.kt)("li",{parentName:"ul"},'Now you can see that the output on line 5 is the string "hello".'),(0,i.kt)("li",{parentName:"ul"},"So, the ",(0,i.kt)("inlineCode",{parentName:"li"},"async")," keyword ensures that the function returns a promise, but it's not just that. The real advantage of async functions becomes evident when you combine them with the ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," keyword.")),(0,i.kt)("h4",{id:"the-await-keyword"},"The await Keyword"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The first point is that the ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," keyword can be put in front of any async promise-based function to pause your code until the promise settles and returns its result."),(0,i.kt)("li",{parentName:"ul"},"In simple terms, you can say that the ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," operator makes JavaScript wait until the promise settles and returns a result."),(0,i.kt)("li",{parentName:"ul"},"The second point about the ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," keyword is that it only works inside async functions; you cannot use ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," in normal functions."),(0,i.kt)("li",{parentName:"ul"},"Let's understand this with an example:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"We have an async function ",(0,i.kt)("inlineCode",{parentName:"li"},"greet"),"."),(0,i.kt)("li",{parentName:"ul"},"Within the function body, on line three, we create a promise that resolves after one second."),(0,i.kt)("li",{parentName:"ul"},"We store the promise in a variable called ",(0,i.kt)("inlineCode",{parentName:"li"},"promise"),"."),(0,i.kt)("li",{parentName:"ul"},"In the next line, we ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," the promise and assign the returned value to the ",(0,i.kt)("inlineCode",{parentName:"li"},"result")," variable."),(0,i.kt)("li",{parentName:"ul"},"On line 9, we log the ",(0,i.kt)("inlineCode",{parentName:"li"},"result"),' to the console, which prints "hello."'))),(0,i.kt)("li",{parentName:"ul"},"What is happening here is that the ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," keyword basically pauses code execution until the promise settles."),(0,i.kt)("li",{parentName:"ul"},'In this example, the promise takes one second to settle, so after a second, the execution resumes, and "hello" is logged to the console.'),(0,i.kt)("li",{parentName:"ul"},"It's important to note here that the ",(0,i.kt)("inlineCode",{parentName:"li"},"await")," keyword literally suspends the ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," function execution until the promise settles and then resumes it with the promise return value."),(0,i.kt)("li",{parentName:"ul"},"The JavaScript engine can do other tasks in the meantime, but as far as the ",(0,i.kt)("inlineCode",{parentName:"li"},"greet")," function is concerned, there is one second of suspension where no further code will execute."),(0,i.kt)("li",{parentName:"ul"},"If we go back to the promise chaining example we had a look at in the previous lecture, we can rewrite it using ",(0,i.kt)("inlineCode",{parentName:"li"},"async/await")," in the following way:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"async function getData() {\n  try {\n    const user = await fetchUser()\n    const followers = await fetchFollowers(user.id)\n    const interests = await fetchInterests(followers[0].id)\n    const tags = await fetchTags(interests[0].id)\n    const description = await fetchDescription(tags[0].id)\n    displayData(description)\n  } catch (error) {\n    handleError(error)\n  }\n}\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"You can see that the code resembles synchronous code and is even more readable than a promise chain."),(0,i.kt)("li",{parentName:"ul"},"In fact, error handling is also simplified, as you can simply use try-c")))),(0,i.kt)("h3",{id:"-event-loop"},(0,i.kt)("strong",{parentName:"h3"},"=>")," Event Loop"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"In this lecture, let's understand the all-important event loop in JavaScript."),(0,i.kt)("li",{parentName:"ul"},"What do you know about the event loop in JavaScript? It's a popular question for a senior front-end developer interview."),(0,i.kt)("li",{parentName:"ul"},"Learning about the event loop early in your career as a front-end developer can help you write better asynchronous code."),(0,i.kt)("li",{parentName:"ul"},"We'll divide this discussion on the event loop into four concise lectures."),(0,i.kt)("li",{parentName:"ul"},"In this lecture, we'll start with a small recap of async programming in JavaScript and introduce the essential components for running asynchronous code."),(0,i.kt)("li",{parentName:"ul"},"We'll also see how these components work during the execution of a simple synchronous code snippet."),(0,i.kt)("li",{parentName:"ul"},"In the next three lectures, we'll explore the same concepts with asynchronous code snippets."),(0,i.kt)("li",{parentName:"ul"},"We'll dive deeper into how ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout")," code executes, how promises work, and finally, how code combining these topics executes."),(0,i.kt)("li",{parentName:"ul"},"By the end of the fourth lecture, you'll have a better understanding of async JavaScript and JavaScript in general.")),(0,i.kt)("h4",{id:"recap-of-async-programming-in-javascript"},"Recap of Async Programming in JavaScript"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"JavaScript is a synchronous, blocking, single-threaded language."),(0,i.kt)("li",{parentName:"ul"},"To make async programming possible, JavaScript alone isn't enough; we also need the web browser."),(0,i.kt)("li",{parentName:"ul"},"The JavaScript runtime environment includes the JavaScript engine, memory heap, call stack, web APIs, callback queue (or task queue), and the event loop."),(0,i.kt)("li",{parentName:"ul"},"The JavaScript engine consists of a memory heap and a call stack."),(0,i.kt)("li",{parentName:"ul"},"Variables and functions are allocated memory in the heap, and functions are pushed onto the call stack when executed."),(0,i.kt)("li",{parentName:"ul"},"Web APIs provide features like ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"Promise"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"XMLHttpRequest"),", and the DOM, which are not implemented in JavaScript itself."),(0,i.kt)("li",{parentName:"ul"},"Callback queue (or task queue) stores callbacks that are ready to be executed."),(0,i.kt)("li",{parentName:"ul"},"The event loop checks if the call stack is empty; if so, it pushes items from the queue onto the stack.")),(0,i.kt)("h4",{id:"synchronous-code-execution"},"Synchronous Code Execution"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Visualizing the execution of a simple synchronous code snippet."),(0,i.kt)("li",{parentName:"ul"},"Demonstrated with a code snippet containing three ",(0,i.kt)("inlineCode",{parentName:"li"},"console.log")," statements."),(0,i.kt)("li",{parentName:"ul"},"Explained how functions are pushed onto the call stack, executed, and popped off in a last-in, first-out manner."),(0,i.kt)("li",{parentName:"ul"},"Showed how synchronous code runs in a straightforward manner without involving the callback queue or event loop.")),(0,i.kt)("h4",{id:"conclusion-2"},"Conclusion"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Understanding how the call stack works is crucial for understanding asynchronous code."),(0,i.kt)("li",{parentName:"ul"},"Introduced the key components of the JavaScript runtime environment."),(0,i.kt)("li",{parentName:"ul"},"In the next lecture, we'll delve into the execution of code involving ",(0,i.kt)("inlineCode",{parentName:"li"},"setTimeout"),".")))}p.isMDXComponent=!0}}]);